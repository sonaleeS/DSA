// ******************* Introduction to Stack and Queues*******************

// #What is a Stack?
// Stack follows the LIFO (Last-In-First-Out) principle. The last element added is the first one to come out.

// #Stack Operations
// 1.Push: Add an element to the top
// 2.Pop: Remove the top element
// 3.Peek/Top: View the top-most element

// #Visualisation stack :
//     Example Flow
//     stack.push(1) ‚Üí [1]
//     stack.push(3) ‚Üí [1, 3]
//     stack.pop() ‚Üí returns 3 ‚Üí [1]
//     stack.peek() ‚Üí returns 1
//     Examples:
//     Stacks of Books
//     Undo/Redo feature
//     Recursion (Function Call Stack)
//     Browsing History

// #What is a Queue?
// Queue follows the FIFO (First-In-First-Out) principle. The first element added is the first to be removed.

// #Queue Operations
// 1.Enqueue: Add an element to the end
// 2.Dequeue: Remove element from the front
// 3.Peek/Front: View the front-most element

// #Visualisation Queue:
//     Examples
//     Ticket Counter
//     OS Task Scheduling
//     Printers
//     Queues (in general)

// #Why Use Stack and Queue‚ùì
// Organize data logically (based on problem‚Äôs need).
// Order of Operations Matter
// Optimize time & memory for specific scenarios
// Use Cases
// Recursion (stack)
// Level Order Traversal (queue)
// BFS (queue)
// DFS (stack)
// Language Implementation
// JavaScript

// let stack = [];
// stack.push(10);
// stack.push(7);
// stack.pop();    // returns 7
// stack.pop();    // returns 10

// Stack vs Queue

// üì• Stack
// Last-In-First-Out
// Access only from top
// Used in DFS, Recursion

// üì§ Queue
// First-In-First-Out
// Access from front & rear
// Used in BFS, Scheduling
// comparison with other Data-Structures
// table
